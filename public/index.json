[{"content":"The notion behind this project was to create a trainer for Witcher 1: Enhanced Edition.\nTrainer aims to include the following cheats:\n GOD Mode No Toxicity Full Endurance Minimum Talent Minimum Orens Bronze Talents (Increase/Decrease) Silver Talents (Increase/Decrease) Gold Talents (Increase/Decrease) Exp (Increase/Decrease)  The init of hunt Since two months, I\u0026rsquo;ve developed a strong feelings for and enjoyment of game hacking. As this allowed me to learn about exciting new topics and pretty much exclusively allows me to make games do what I want them to do.\nSo, my plan for today is to get the player address from the game by function hooking a method at a specific instruction via DLL injection.\nI won\u0026rsquo;t go through the specifics of detecting different entity addresses through memory scanning because there are lots of websites that will assist you:\n CS420 Game Hacking Course Cheat Engine: Finding Encrypted Values and Manipulating The Stack Cheat Engine How to Pointer Scan with Pointermaps How To Find Offsets, Entity Addresses \u0026amp; Pointers  Through the agony of memory scanning using Cheat Engine, I discovered that hooking the instruction at witcher.exe+0037a59d allows to access the player address stored in the register ecx.\nYou might be wondering how one hooks an instruction to acquire the value from a register. So, after some \u0026ldquo;research\u0026rdquo; (googling \u0026ldquo;how to hook\u0026rdquo; and reading various articles), discovered that detour hooking allows us to change the assembly instructions.\nBut before you keep listening to me talk about implementing a detour hook for the Witcher, I would say to understand what hooking stands for.\nSome awesome resources:\n x86 API Hooking Demystified X64 Function Hooking by Example How to Hook Functions  I understand; we are too sluggish to read or switch to a new post to learn something. So, for the time being, I\u0026rsquo;ll let you off the hook (no pun intended) and offer you a general understanding about hooking.\nA function hook is a method of intercepting a function call and redirecting it to a different user-defined function. This is accomplished by altering the bytes of the compiled to create the jump. Jump instruction with the address of the payload function are used to overwrite the bytes, for example, E9 44 64 23 11 - this instruction corresponds to jmp 11236444. Now lets slay some monsters.\nWind\u0026rsquo;s howling As previously stated, the aim for today is to create a DLL that obtains the player address and verifying it using a string comparison. Hooking the mentioned instruction should do the trick.\nAfter a lot of trial and error, I discovered that the way I was implementing the hack was incorrect.\nMy first thought was to create a dll that would detour hook the instruction at witcher.exe+0037a59d and retrieve the player address from the register ecx.\nThe original instructions that will be overwritten are:\nwitcher.exe+37A59D - D9 41 54 - fld dword ptr [ecx+54] witcher.exe+37A5A0 - D8 41 48 - fadd dword ptr [ecx+48] Hooking Inspiring from the tutorial of Detour Hooking, the steps of implementing a hook is simple:\n  Change the memory protect status to able to read and write\nVirtualProtect(func2Hook, len, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtect);   Set all the bytes to NOP (0x90), of defined size. This would make sure that they aren\u0026rsquo;t irrelevant bytes\nmemset(func2Hook, 0x90, len);   Now follows the crucial hooking part. Set the first byte to 0xE9, which is a jump instruction representation, and after calculating the relative jump address from the function to be hooked and our function, write the bytes following the jump instruction\nDWORD relativeAddress = (((DWORD)payloadFunc - (DWORD)func2Hook) - 5); *(BYTE*)func2Hook = 0xE9; *(BYTE*)((DWORD)func2Hook + 1) = relativeAddress;   The hook function This is the point at which I made the assumption that I would go around applying this hack.\nThe basic idea is to copy the value from the register onto a global, which may subsequently be used to implement other exploits. It was supposed to run the original instructions and then return to the next instruction after receiving the variable.\nThe following is the code used:\nuintptr_t playerEntity; DWORD jumpAddy; void __declspec(naked) GetPlayerAddress() { __asm { mov [playerEntity], ecx fld dword ptr[ecx + 54] // Original code  fadd dword ptr[ecx + 48] // Original code  jmp [jumpAddy]; } } Pain and realization As previously stated, this technique of implementation has shown to be ineffective. The game breaks every time the dll is injected, and debugging with Visual Studio revealed that the injected code is not being executed.\nAfter a little more suffering and research, I discovered that this method of implementation is better written as a shell code injection. Shell injection is used to inject code into the target process that is typically written in assembly.\nAhh, after some thought, I think I\u0026rsquo;ve figured out what I\u0026rsquo;ve been doing incorrectly. Stay tuned for the idiotic mistake!\nAssuming you loved this cry for help article, will see you later!\nFinal code // Function to hook a function bool DetourHook(void* func2Hook, void* payloadFunc, int len) { // Length should atleast be of size 5  if (len \u0026lt; 5) return false; // Gain READWRITE control over a specific area of memory  DWORD oldProtect; VirtualProtect(func2Hook, len, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtect); // Set all the bytes of func2Hook to NOP (0x90)  memset(func2Hook, 0x90, len); // Get relative address of payload function  DWORD relativeAddress = (((DWORD)payloadFunc - (DWORD)func2Hook) - 5); // Set first byte to jmp instruction (0xE9)  *(BYTE*)func2Hook = 0xE9; // Set next four bytes to the relative address  *(BYTE*)((DWORD)func2Hook + 1) = relativeAddress; // Revert back to previous mem status  VirtualProtect(func2Hook, len, oldProtect, \u0026amp;oldProtect); return true; } // Writing bytes to dst from src void Revert(BYTE* dist, BYTE* source, DWORD len) { DWORD oldProtect; VirtualProtect(dist, len, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtect); memcpy(dist, source, len); VirtualProtect(dist, len, oldProtect, \u0026amp;oldProtect); } // Payload function to get player address uintptr_t playerEntity = 0; DWORD jumpAddy; void __declspec(naked) GetPlayerAddress() { __asm { mov [playerEntity], ecx fld dword ptr[ecx + 54] // Original code  fadd dword ptr[ecx + 48] // Original code  jmp [jumpAddy]; } } DWORD WINAPI ConThread(HMODULE hMod) { AllocConsole(); FILE* file; freopen_s(\u0026amp;file, \u0026#34;CONOUT$\u0026#34;, \u0026#34;w\u0026#34;, stdout); printf(\u0026#34;Hunting Witcher\\n\u0026#34;); int hookLen = 6; DWORD hookAddress = (DWORD)(GetModuleHandle(L\u0026#34;witcher.exe\u0026#34;)) + 0x0037a59d; jumpAddy = hookAddress + hookLen; if (DetourHook((void*)hookAddress, (void*)GetPlayerAddress, hookLen)) { printf(\u0026#34;Player Address: 0x%X\u0026#34;, playerEntity); } else printf(\u0026#34;Hooking failed\\n\u0026#34;); while (true) { if (GetAsyncKeyState(VK_END) \u0026amp; 1) break; Sleep(50); } if (file != NULL) fclose(file); FreeConsole(); FreeLibraryAndExitThread(hMod, 0); return 0; } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)ConThread, hModule, 0, 0)); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } ","permalink":"https://70xhandler.com/posts/witcherenhanced/day000/","summary":"Initial idea of a new project","title":"Day 000 - The Hunt for the Witcher"}]